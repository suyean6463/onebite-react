# 최적화
> 웹 서비스의 성능을 개선하는 모든 행위를 일컫음. 아주 단순한 것부터 아주 어려운 방법까지 매우 다양함.

## 일반적인 웹 서비스 최적화 방법
- 서버의 응답속도 개선
- 이미지, 폰트, 코드 파일 등의 정적 파일 로딩 개선
- 불필요한 네트워크 요청 줄이기

## React App 내부의 최적화 방법
- 컴포넌트 내부의 불필요한 연산 방지
- 컴포넌트 내부의 불필요한 함수 재생성 방지
- 컴포넌트의 불필요한 리렌더링 방지

### useMemo - 불필요한 연산 방지
> '메모이제이션' 기법을 기반으로 불필요한 연산을 최적화하는 리액트 훅
- 메모이제이션이란, 반복적으로 수행되는 동일한 연산에서 매번 결과값을 새롭게 연산하지 않고 최초 연산에서 결과값을 메모리에 저장하고
  다시 동일한 연산이 필요해지면 저장되어있던 결과값을 돌려주는 기법 (동일한 연산을 불필요하게 다시 수행할 필요가 없음)
- `useMemo(()=>{}, [])` <br> []은 의존성 배열 deps로, useEffect와 동일하게 deps에 포함된 값이 변경되었을 때만 첫번째 인수로 전달된 콜백함수 실행

### React.memo - 불필요한 리렌더링 방지
> React.memo란, 컴포넌트를 인수로 받아, 최적화된 컴포넌트를 만들어 결과값으로 반환<br>
`const MomoizedComponent = memo(Component)`
- MomoizedComponent : 반환값(최적화된 컴포넌트)
  - 최적화 기능이 추가된 컴포넌트는 props를 기준으로 메모이제이션 됨
  - MomoizedComponent는 부모 컴포넌트가 리렌더링되더라도 자신이 받는 props가 바뀌지 않으면 리렌더링 발생 X(메모이제이션)
  - 현재의 props와 과거의 props를 비교해서 값의 동일 여부를 판단해서 컴포넌트의 리렌더링 유무를 판단
- Component : 인수

#### 객체타입을 props로 받는 컴포넌트에 memo 메서드 적용하기
> 예로들어, todos의 값이 바뀜에 따라 App 컴포넌트가 리렌더링되면 onCreate, onUpdate, onDelete 와 같은 함수들도 새롭게 생성<br>
함수는 객체 타입으로 새롭게 생성된 함수들은 같은 동작을 하더라도 다른 값으로 인식 됨(얕은 비교로 판단)
- 객체 타입은 주소값으로 저장이 되고, 객체 간의 비교는 주소값으로 수행하기 때문에 같은 값을 가져도 서로 다른 객체라고 판단
- 따라서, 객체타입을 props로 받는 컴포넌트는 props가 계속 바뀐다고 인식되어 최적화가 제대로 수행되지 않음
  - useCallback : 함수들 자체를 메모이제이션해서 리렌더링 되더라도 다시 생성되지 않도록 방지하는 방법
  - memo 함수 안에 두번째 인수로 콜백함수를 전달해서 최적화 기능을 커스터마이징하는 방법
    - `memo(TodoItem, (prevProps, nextProps)=>{} )`
    -  부모가 리렌더링될 때마다 컴포넌트의 props가 바뀌었는지 스스로 판단하는게 아니라,<br>콜백함수의 반환값에 따라서 prop 바뀜 여부 판단
      -  반환값 `true` : props 바뀌지 않음, 리렌더링 X
      -  반환값 `false` : props 바뀜, 리렌더링 O

### useCallback - 불필요한 함수 재생성 방지
> memo 메서드는 얕은 비교로 판단하기 때문에, 객체타입을 props로 받는 컴포넌트인 경우 적합하지 않음<br>
props의 이름이 변경되거나 추가될 경우 새로운 조건문을 계속 추가해야함
- `useCallback(() => {}, [])`
